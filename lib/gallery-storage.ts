import { supabase } from "./supabase"
import type { FlowArtSettings } from "./flow-model"

export interface GalleryImageMetadata {
  dataset: string
  scenario: string
  colorScheme: string
  seed: number
  samples: number
  noise: number
  generationMode: "svg" | "ai"
  createdAt: number // Unix timestamp
  filename: string
  fileSize: number // in bytes
  cloudStored: boolean
  aiPrompt?: string
  aiDescription?: string
  aestheticScore?: {
    score: number
    rating: string
    method: string
  }
  uploadedAt?: number // Unix timestamp for cloud upload
  originalSize?: number // Original size before compression for cloud
}

export interface GalleryImage {
  id: string
  imageUrl: string // Data URL or Blob URL
  metadata: FlowArtSettings & {
    createdAt: number
    filename: string
    fileSize: number // in bytes
    cloudStored: boolean
    aiDescription?: string // The full prompt generated by AI
  }
  isFavorite: boolean
  tags: string[]
}

export interface FlowArtSettingsPreset {
  dataset: GalleryImageMetadata["dataset"]
  scenario: GalleryImageMetadata["scenario"]
  colorScheme: GalleryImageMetadata["colorScheme"]
  seed: GalleryImageMetadata["seed"]
  samples: GalleryImageMetadata["samples"]
  noise: GalleryImageMetadata["noise"]
  generationMode: GalleryImageMetadata["generationMode"]
  aiPrompt?: string
  aiNegativePrompt?: string
}

export interface StorageInfo {
  used: number // in bytes
  available: number // in bytes
}

export interface StorageStats {
  localImages: number
  cloudImages: number
  totalSize: number // in bytes
  averageSize: number // in bytes
  largestImage: number // in bytes
  averageScore: number
  topRatedImages: number
}

const LOCAL_STORAGE_KEY = "flowsketch-gallery"
const PRESETS_STORAGE_KEY = "flowsketch-presets"
const STORAGE_KEY = "flowsketch_gallery_v1"
export const MAX_LOCAL_STORAGE = 50 * 1024 * 1024 // 50 MB

interface GalleryState {
  images: { [id: string]: GalleryImage }
  presets: { [name: string]: FlowArtSettings & { aiPrompt?: string; aiNegativePrompt?: string } }
}

const galleryState: GalleryState = {
  images: {},
  presets: {},
}

function loadState(): GalleryState {
  if (typeof window === "undefined") {
    return galleryState
  }
  try {
    const serializedState = localStorage.getItem(STORAGE_KEY)
    if (serializedState === null) {
      return galleryState
    }
    const parsedState: GalleryState = JSON.parse(serializedState)
    // Ensure images and presets are objects, not null/undefined
    parsedState.images = parsedState.images || {}
    parsedState.presets = parsedState.presets || {}
    return parsedState
  } catch (error) {
    console.error("Error loading gallery state from localStorage:", error)
    return galleryState
  }
}

function saveState(state: GalleryState) {
  if (typeof window === "undefined") {
    return
  }
  try {
    const serializedState = JSON.stringify(state)
    localStorage.setItem(STORAGE_KEY, serializedState)
  } catch (error) {
    console.error("Error saving gallery state to localStorage:", error)
  }
}

// Listeners for gallery changes
const changeListeners = new Set<() => void>()

function notifyListeners() {
  changeListeners.forEach((listener) => listener())
}

export const GalleryStorage = {
  getAllImages(): GalleryImage[] {
    return Object.values(loadState().images).sort((a, b) => b.metadata.createdAt - a.metadata.createdAt)
  },

  getImage(id: string): GalleryImage | undefined {
    return loadState().images[id]
  },

  saveImage(image: GalleryImage) {
    const currentState = loadState()
    currentState.images[image.id] = image
    saveState(currentState)
    window.dispatchEvent(new Event("storage")) // Notify other tabs/components
  },

  deleteImage(id: string) {
    const currentState = loadState()
    delete currentState.images[id]
    saveState(currentState)
    window.dispatchEvent(new Event("storage"))
  },

  updateImageMetadata(id: string, updates: Partial<GalleryImage["metadata"]>) {
    const currentState = loadState()
    if (currentState.images[id]) {
      currentState.images[id].metadata = {
        ...currentState.images[id].metadata,
        ...updates,
      }
      saveState(currentState)
      window.dispatchEvent(new Event("storage"))
    }
  },

  toggleFavorite(id: string) {
    const currentState = loadState()
    if (currentState.images[id]) {
      currentState.images[id].isFavorite = !currentState.images[id].isFavorite
      saveState(currentState)
      window.dispatchEvent(new Event("storage"))
    }
  },

  getPresets(): GalleryState["presets"] {
    return loadState().presets
  },

  savePreset(name: string, settings: FlowArtSettings & { aiPrompt?: string; aiNegativePrompt?: string }) {
    const currentState = loadState()
    currentState.presets[name] = settings
    saveState(currentState)
    window.dispatchEvent(new Event("storage"))
  },

  deletePreset(name: string) {
    const currentState = loadState()
    delete currentState.presets[name]
    saveState(currentState)
    window.dispatchEvent(new Event("storage"))
  },

  formatFileSize(bytes: number): string {
    if (bytes === 0) return "0 Bytes"
    const k = 1024
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"]
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    return Number.parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i]
  },

  getStorageInfo(): StorageInfo {
    if (typeof navigator === "undefined" || !navigator.storage || !navigator.storage.estimate) {
      console.warn("StorageManager API not supported. Cannot estimate storage usage.")
      // Fallback to a rough estimate based on localStorage size
      const localStorageSize = new TextEncoder().encode(JSON.stringify(localStorage)).length
      return {
        used: localStorageSize,
        available: MAX_LOCAL_STORAGE - localStorageSize,
      }
    }

    // This is an async operation, but we need a synchronous return for useState.
    // In a real app, you'd handle this with async state updates.
    // For now, we'll return a placeholder and update later.
    navigator.storage.estimate().then((estimate) => {
      // This part would typically trigger a state update in a React component
      // that calls getStorageInfo, but this function itself is synchronous.
      // For simplicity in this example, we'll just log it.
      console.log(
        `Storage used: ${this.formatFileSize(estimate.usage || 0)}, quota: ${this.formatFileSize(estimate.quota || 0)}`,
      )
    })

    // Return a dummy value or current localStorage size for immediate use
    const localStorageSize = new TextEncoder().encode(JSON.stringify(localStorage)).length
    return {
      used: localStorageSize,
      available: MAX_LOCAL_STORAGE - localStorageSize, // Placeholder
    }
  },

  getStorageStats(gallery: GalleryImage[]): StorageStats {
    const localImages = gallery.length
    const cloudImages = gallery.filter((img) => img.metadata?.cloudStored).length
    const totalSize = gallery.reduce((sum, img) => sum + (img.metadata?.fileSize || 0), 0)
    const averageSize = localImages > 0 ? totalSize / localImages : 0

    const largestImage = gallery.reduce((max, img) => Math.max(max, img.metadata?.fileSize || 0), 0)

    const scoredImages = gallery.filter((img) => img.metadata?.aestheticScore)
    const totalScore = scoredImages.reduce((sum, img) => sum + (img.metadata?.aestheticScore?.score || 0), 0)
    const averageScore = scoredImages.length > 0 ? totalScore / scoredImages.length : 0

    const topRatedImages = gallery.filter((img) => (img.metadata?.aestheticScore?.score || 0) >= 7.0).length

    return {
      localImages,
      cloudImages,
      totalSize,
      averageSize,
      largestImage,
      averageScore,
      topRatedImages,
    }
  },

  getScoreBadgeVariant(score: number): "default" | "secondary" | "destructive" | "outline" {
    if (score >= 8.0) return "default" // High score, good
    if (score >= 6.0) return "secondary" // Medium score
    if (score < 4.0) return "destructive" // Low score, needs improvement
    return "outline" // Average
  },

  async uploadImageToCloud(image: GalleryImage): Promise<string | null> {
    if (!supabase) {
      console.error("Supabase client is not initialized.")
      return null
    }

    try {
      const {
        data: { user },
      } = await supabase.auth.getUser()
      if (!user) {
        console.error("User not authenticated for cloud upload.")
        return null
      }

      // Determine file type and extension
      const isSvg = image.imageUrl.startsWith("data:image/svg+xml")
      const fileExtension = isSvg ? "svg" : "png"
      const contentType = isSvg ? "image/svg+xml" : "image/png"
      const fileName = `${user.id}/${image.id}.${fileExtension}`

      // Convert data URL to Blob
      const response = await fetch(image.imageUrl)
      const blob = await response.blob()

      // Upload to Supabase Storage
      const { data, error } = await supabase.storage.from("gallery-images").upload(fileName, blob, {
        contentType: contentType,
        upsert: true, // Overwrite if file exists
      })

      if (error) {
        console.error("Error uploading image to Supabase Storage:", error)
        return null
      }

      // Get public URL
      const { data: publicUrlData } = supabase.storage.from("gallery-images").getPublicUrl(fileName)

      if (publicUrlData?.publicUrl) {
        // Update image in DB with cloud URL and metadata
        const { error: dbError } = await supabase.from("gallery_images").upsert(
          {
            id: image.id,
            user_id: user.id,
            image_url: publicUrlData.publicUrl,
            metadata: {
              ...image.metadata,
              cloudStored: true,
              uploadedAt: Date.now(),
              fileSize: blob.size, // Update with actual uploaded file size
            },
            is_favorite: image.isFavorite,
            tags: image.tags,
          },
          { onConflict: "id" }, // Update if ID exists
        )

        if (dbError) {
          console.error("Error updating image in Supabase DB after upload:", dbError)
          return null
        }

        return publicUrlData.publicUrl
      }
      return null
    } catch (error) {
      console.error("Unexpected error during cloud upload:", error)
      return null
    }
  },

  async downloadImageFromCloud(pathInStorage: string): Promise<string | null> {
    if (!supabase) {
      console.error("Supabase client is not initialized.")
      return null
    }

    try {
      const { data, error } = await supabase.storage.from("gallery-images").download(pathInStorage)

      if (error) {
        console.error("Error downloading image from Supabase Storage:", error)
        return null
      }

      const reader = new FileReader()
      return new Promise((resolve, reject) => {
        reader.onloadend = () => resolve(reader.result as string)
        reader.onerror = reject
        reader.readAsDataURL(data)
      })
    } catch (error) {
      console.error("Unexpected error during cloud download:", error)
      return null
    }
  },

  async deleteImageFromCloud(imageId: string): Promise<boolean> {
    if (!supabase) {
      console.error("Supabase client is not initialized.")
      return false
    }

    try {
      const {
        data: { user },
      } = await supabase.auth.getUser()
      if (!user) {
        console.error("User not authenticated for cloud delete.")
        return false
      }

      // Attempt to delete both .png and .svg versions
      const filesToDelete = [`${user.id}/${imageId}.png`, `${user.id}/${imageId}.svg`]

      const { error: storageError } = await supabase.storage.from("gallery-images").remove(filesToDelete)

      if (storageError) {
        console.error("Error deleting image from Supabase Storage:", storageError)
        return false
      }

      // Delete from database
      const { error: dbError } = await supabase.from("gallery_images").delete().eq("id", imageId).eq("user_id", user.id)

      if (dbError) {
        console.error("Error deleting image from Supabase DB:", dbError)
        return false
      }

      return true
    } catch (error) {
      console.error("Unexpected error during cloud delete:", error)
      return false
    }
  },

  async scoreImage(imageId: string): Promise<{ success: boolean; error?: string }> {
    const image = this.getImage(imageId)
    if (!image) {
      return { success: false, error: "Image not found in gallery." }
    }

    try {
      const response = await fetch("/api/score-image", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          imageUrl: image.imageUrl, // Pass the image URL for potential future vision model use
          metadata: image.metadata,
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || "Failed to score image via API.")
      }

      const result = await response.json()
      this.updateImageMetadata(image.id, { aestheticScore: result })

      // If cloud stored, update in Supabase as well
      if (image.metadata.cloudStored && supabase) {
        const { error: dbError } = await supabase
          .from("gallery_images")
          .update({ aesthetic_score: result })
          .eq("id", image.id)
          .eq("user_id", (await supabase.auth.getUser()).data.user?.id)

        if (dbError) {
          console.error("Error updating aesthetic score in Supabase DB:", dbError)
          // Don't fail the whole operation, but log it
        }
      }

      return { success: true }
    } catch (error: any) {
      console.error("Error scoring image:", error)
      return { success: false, error: error.message }
    }
  },

  async batchScoreImages(onProgress?: (progress: number) => void): Promise<{ scored: number; failed: number }> {
    const gallery = this.getAllImages()
    const unscoredImages = gallery.filter((img) => !img.metadata?.aestheticScore)
    let scoredCount = 0
    let failedCount = 0

    for (let i = 0; i < unscoredImages.length; i++) {
      const image = unscoredImages[i]
      onProgress?.(((i + 1) / unscoredImages.length) * 100)
      const result = await this.scoreImage(image.id)
      if (result.success) {
        scoredCount++
      } else {
        failedCount++
        console.error(`Failed to score image ${image.id}: ${result.error}`)
      }
      // Add a small delay to avoid hitting API rate limits
      await new Promise((resolve) => setTimeout(resolve, 500))
    }
    return { scored: scoredCount, failed: failedCount }
  },

  exportGallery(): string {
    const gallery = this.getAllImages()
    return JSON.stringify(gallery, null, 2)
  },

  importGallery(jsonString: string): boolean {
    try {
      const importedGallery: GalleryImage[] = JSON.parse(jsonString)
      if (!Array.isArray(importedGallery) || !importedGallery.every((img) => img.id && img.imageUrl && img.metadata)) {
        console.error("Invalid imported gallery format.")
        return false
      }

      // Merge with existing gallery, prioritizing imported images by ID
      const currentGallery = this.getAllImages()
      const mergedGalleryMap = new Map<string, GalleryImage>()

      currentGallery.forEach((img) => mergedGalleryMap.set(img.id, img))
      importedGallery.forEach((img) => {
        // Sanitize imported image metadata
        const sanitizedImage: GalleryImage = {
          ...img,
          metadata: {
            createdAt: img.metadata?.createdAt || Date.now(),
            filename: img.metadata?.filename || `flowsketch-art-${img.id}.png`,
            fileSize: img.metadata?.fileSize || 0,
            cloudStored: img.metadata?.cloudStored || false,
            dataset: img.metadata?.dataset || "unknown",
            scenario: img.metadata?.scenario || "none",
            colorScheme: img.metadata?.colorScheme || "viridis",
            seed: img.metadata?.seed || 0,
            samples: img.metadata?.samples || 0,
            noise: img.metadata?.noise || 0,
            generationMode: img.metadata?.generationMode || "svg",
            aiPrompt: img.metadata?.aiPrompt,
            aiDescription: img.metadata?.aiDescription,
            aestheticScore: img.metadata?.aestheticScore,
            uploadedAt: img.metadata?.uploadedAt,
            originalSize: img.metadata?.originalSize,
          },
          imageUrl: img.imageUrl || "/placeholder.png",
        }
        mergedGalleryMap.set(img.id, sanitizedImage)
      })

      const finalGallery = Array.from(mergedGalleryMap.values())
      finalGallery.forEach((img) => this.saveImage(img))
      return true
    } catch (error) {
      console.error("Error importing gallery:", error)
      return false
    }
  },
}

export function getGalleryImages(): GalleryImage[] {
  return GalleryStorage.getAllImages()
}
