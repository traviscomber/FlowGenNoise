"use client"

import { generateFlowArtData, type FlowParameters } from "./flow-model"

/**
 * Draws the flow art data onto a canvas.
 * @param canvas The HTMLCanvasElement to draw on.
 * @param data The array of points and colors generated by the flow model.
 * @param colorScheme The color scheme used for the art.
 * @param stereographic Whether stereographic projection is enabled.
 */
export function drawFlowArt(
  canvas: HTMLCanvasElement,
  data: { x: number; y: number; color: string }[],
  colorScheme: string,
  stereographic: boolean,
) {
  const ctx = canvas.getContext("2d")
  if (!ctx) return

  const dpr = window.devicePixelRatio || 1
  const rect = canvas.getBoundingClientRect()
  canvas.width = rect.width * dpr
  canvas.height = rect.height * dpr
  ctx.scale(dpr, dpr)

  ctx.clearRect(0, 0, canvas.width, canvas.height)
  ctx.fillStyle = "black" // Or a background color based on scheme
  ctx.fillRect(0, 0, canvas.width, canvas.height)

  // Adjust scale and translation for drawing
  const scale = Math.min(rect.width, rect.height) / 2.2 // Adjust to fit within view
  const translateX = rect.width / 2
  const translateY = rect.height / 2

  data.forEach((point) => {
    ctx.beginPath()
    ctx.arc(
      point.x * scale + translateX,
      point.y * scale + translateY,
      0.5, // Point size
      0,
      Math.PI * 2,
    )
    ctx.fillStyle = point.color
    ctx.fill()
  })
}

/**
 * Converts canvas content to a data URL.
 * @param canvas The HTMLCanvasElement to convert.
 * @returns A data URL string.
 */
export function getCanvasDataUrl(canvas: HTMLCanvasElement): string {
  return canvas.toDataURL("image/png")
}

/**
 * Generates an SVG data URL from flow art data.
 * This is a simplified representation and might not perfectly match canvas rendering.
 * For complex mathematical art, rendering directly to canvas and then converting to PNG is often preferred.
 * @param data The array of points and colors.
 * @param colorScheme The color scheme.
 * @param stereographic Whether stereographic projection is enabled.
 * @param width The width of the SVG.
 * @param height The height of the SVG.
 * @returns A data URL string for the SVG.
 */
export function getSvgDataUrl(
  data: { x: number; y: number; color: string }[],
  colorScheme: string,
  stereographic: boolean,
  width: number,
  height: number,
): string {
  const scale = Math.min(width, height) / 2.2
  const translateX = width / 2
  const translateY = height / 2

  const circles = data
    .map(
      (point) =>
        `<circle cx="${point.x * scale + translateX}" cy="${point.y * scale + translateY}" r="0.5" fill="${point.color}" opacity="0.7"/>`,
    )
    .join("")

  const svgContent = `
    <svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">
      <rect width="100%" height="100%" fill="#1a1a1a"/>
      ${circles}
    </svg>
  `
  return `data:image/svg+xml;base64,${btoa(svgContent)}`
}

/**
 * Downloads an image from a data URL.
 * @param dataUrl The data URL of the image to download.
 * @param filename The desired filename for the downloaded image.
 */
export function downloadImage(dataUrl: string, filename: string) {
  const link = document.createElement("a")
  link.href = dataUrl
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
}

/**
 * Generates an SVG from flow art parameters.
 * @param params The flow art parameters.
 * @returns An SVG string.
 */
export function generateSvgFromFlowData(params: FlowParameters): string {
  const { dataset, scenario, colorScheme, seed, noise, samples, stereographic } = params
  const points = generateFlowArtData({ dataset, scenario, colorScheme, seed, noise, samples, stereographic })

  const size = 512 // Base size for the SVG
  const centerX = size / 2
  const centerY = size / 2
  const scale = size / 4 // Adjust scale to fit points within the SVG

  let svgContent = `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">`

  // Add a simple background rectangle
  svgContent += `<rect width="${size}" height="${size}" fill="#1a1a1a"/>` // Dark background

  for (const point of points) {
    const screenX = centerX + point.x * scale
    const screenY = centerY + point.y * scale

    // Ensure points are within the SVG bounds
    if (screenX >= 0 && screenX <= size && screenY >= 0 && screenY <= size) {
      svgContent += `<circle cx="${screenX}" cy="${screenY}" r="1.5" fill="${point.color}" opacity="0.7"/>`
    }
  }

  svgContent += "</svg>"
  return svgContent
}
