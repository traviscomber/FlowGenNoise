"use client"

import { generateFlowArtData, type FlowParameters } from "./flow-model"
import { Vector3 } from "three"
import type { FlowField } from "./flow-model"

/**
 * Draws the flow art data onto a canvas.
 * @param canvas The HTMLCanvasElement to draw on.
 * @param data The array of points and colors generated by the flow model.
 * @param colorScheme The color scheme used for the art.
 * @param stereographic Whether stereographic projection is enabled.
 */
export function drawFlowArt(
  canvas: HTMLCanvasElement,
  data: { x: number; y: number; color: string }[],
  colorScheme: string,
  stereographic: boolean,
) {
  const ctx = canvas.getContext("2d")
  if (!ctx) return

  const dpr = window.devicePixelRatio || 1
  const rect = canvas.getBoundingClientRect()
  canvas.width = rect.width * dpr
  canvas.height = rect.height * dpr
  ctx.scale(dpr, dpr)

  ctx.clearRect(0, 0, canvas.width, canvas.height)
  ctx.fillStyle = "black" // Or a background color based on scheme
  ctx.fillRect(0, 0, canvas.width, canvas.height)

  // Adjust scale and translation for drawing
  const scale = Math.min(rect.width, rect.height) / 2.2 // Adjust to fit within view
  const translateX = rect.width / 2
  const translateY = rect.height / 2

  data.forEach((point) => {
    ctx.beginPath()
    ctx.arc(
      point.x * scale + translateX,
      point.y * scale + translateY,
      0.5, // Point size
      0,
      Math.PI * 2,
    )
    ctx.fillStyle = point.color
    ctx.fill()
  })
}

/**
 * Converts canvas content to a data URL.
 * @param canvas The HTMLCanvasElement to convert.
 * @returns A data URL string.
 */
export function getCanvasDataUrl(canvas: HTMLCanvasElement): string {
  return canvas.toDataURL("image/png")
}

/**
 * Generates an SVG data URL from flow art data.
 * This is a simplified representation and might not perfectly match canvas rendering.
 * For complex mathematical art, rendering directly to canvas and then converting to PNG is often preferred.
 * @param data The array of points and colors.
 * @param colorScheme The color scheme.
 * @param stereographic Whether stereographic projection is enabled.
 * @param width The width of the SVG.
 * @param height The height of the SVG.
 * @returns A data URL string for the SVG.
 */
export function getSvgDataUrl(
  data: { x: number; y: number; color: string }[],
  colorScheme: string,
  stereographic: boolean,
  width: number,
  height: number,
): string {
  const scale = Math.min(width, height) / 2.2
  const translateX = width / 2
  const translateY = height / 2

  const circles = data
    .map(
      (point) =>
        `<circle cx="${point.x * scale + translateX}" cy="${point.y * scale + translateY}" r="0.5" fill="${point.color}" opacity="0.7"/>`,
    )
    .join("")

  const svgContent = `
    <svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">
      <rect width="100%" height="100%" fill="#1a1a1a"/>
      ${circles}
    </svg>
  `
  return `data:image/svg+xml;base64,${btoa(svgContent)}`
}

/**
 * Downloads an image from a data URL.
 * @param dataUrl The data URL of the image to download.
 * @param filename The desired filename for the downloaded image.
 */
export function downloadImage(dataUrl: string, filename: string) {
  const link = document.createElement("a")
  link.href = dataUrl
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
}

/**
 * Generates an SVG from flow art parameters.
 * @param params The flow art parameters.
 * @returns An SVG string.
 */
export function generateSvgFromFlowData(params: FlowParameters): string {
  const { dataset, scenario, colorScheme, seed, noise, samples, stereographic } = params
  const points = generateFlowArtData({ dataset, scenario, colorScheme, seed, noise, samples, stereographic })

  const size = 512 // Base size for the SVG
  const centerX = size / 2
  const centerY = size / 2
  const scale = size / 4 // Adjust scale to fit points within the SVG

  let svgContent = `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">`

  // Add a simple background rectangle
  svgContent += `<rect width="${size}" height="${size}" fill="#1a1a1a"/>` // Dark background

  for (const point of points) {
    const screenX = centerX + point.x * scale
    const screenY = centerY + point.y * scale

    // Ensure points are within the SVG bounds
    if (screenX >= 0 && screenX <= size && screenY >= 0 && screenY <= size) {
      svgContent += `<circle cx="${screenX}" cy="${screenY}" r="1.5" fill="${point.color}" opacity="0.7"/>`
    }
  }

  svgContent += "</svg>"
  return svgContent
}

export function generateFlowFieldPoints(
  flow: FlowField,
  initialPosition: Vector3,
  numPoints: number,
  dt: number,
  noiseStrength: number,
  params: any,
  stereographic = false,
): Vector3[] {
  const points: Vector3[] = []
  const currentPosition = initialPosition.clone()

  for (let i = 0; i < numPoints; i++) {
    const flowVector = flow(currentPosition, params).multiplyScalar(dt)

    // Add random noise
    const noise = new Vector3(
      (Math.random() - 0.5) * 2 * noiseStrength,
      (Math.random() - 0.5) * 2 * noiseStrength,
      (Math.random() - 0.5) * 2 * noiseStrength,
    ).multiplyScalar(dt)

    currentPosition.add(flowVector).add(noise)

    if (stereographic) {
      // Stereographic projection from 3D to 2D plane (z=0)
      // P' = (P_x / (1 - P_z), P_y / (1 - P_z), 0) assuming projection from (0,0,1)
      const sx = currentPosition.x / (1 - currentPosition.z)
      const sy = currentPosition.y / (1 - currentPosition.z)
      points.push(new Vector3(sx, sy, 0))
    } else {
      points.push(currentPosition.clone())
    }
  }
  return points
}

export function getMinMax(points: Vector3[]): {
  minX: number
  maxX: number
  minY: number
  maxY: number
  minZ: number
  maxZ: number
} {
  if (points.length === 0) {
    return {
      minX: 0,
      maxX: 0,
      minY: 0,
      maxY: 0,
      minZ: 0,
      maxZ: 0,
    }
  }

  let minX = Number.POSITIVE_INFINITY,
    maxX = Number.NEGATIVE_INFINITY
  let minY = Number.POSITIVE_INFINITY,
    maxY = Number.NEGATIVE_INFINITY
  let minZ = Number.POSITIVE_INFINITY,
    maxZ = Number.NEGATIVE_INFINITY

  for (const p of points) {
    minX = Math.min(minX, p.x)
    maxX = Math.max(maxX, p.x)
    minY = Math.min(minY, p.y)
    maxY = Math.max(maxY, p.y)
    minZ = Math.min(minZ, p.z)
    maxZ = Math.max(maxZ, p.z)
  }

  return { minX, maxX, minY, maxY, minZ, maxZ }
}
